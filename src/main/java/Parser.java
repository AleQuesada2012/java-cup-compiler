
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package main.java;

import java_cup.runtime.*;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import main.java.SymbolTable;
import main.java.MIPS;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\205\000\002\002\004\000\002\012\003\000\002\012" +
    "\003\000\002\012\003\000\002\012\003\000\002\012\003" +
    "\000\002\013\003\000\002\013\003\000\002\013\003\000" +
    "\002\013\003\000\002\013\003\000\002\005\003\000\002" +
    "\005\003\000\002\014\006\000\002\017\006\000\002\016" +
    "\006\000\002\007\003\000\002\007\002\000\002\010\003" +
    "\000\002\010\003\000\002\010\003\000\002\010\003\000" +
    "\002\011\005\000\002\011\003\000\002\004\006\000\002" +
    "\004\004\000\002\006\003\000\002\006\002\000\002\056" +
    "\002\000\002\057\002\000\002\042\014\000\002\060\002" +
    "\000\002\061\002\000\002\042\014\000\002\043\003\000" +
    "\002\043\004\000\002\043\003\000\002\044\002\000\002" +
    "\044\004\000\002\044\003\000\002\035\003\000\002\035" +
    "\003\000\002\035\003\000\002\035\003\000\002\035\003" +
    "\000\002\035\003\000\002\015\003\000\002\015\003\000" +
    "\002\027\003\000\002\027\003\000\002\025\003\000\002" +
    "\025\003\000\002\025\003\000\002\025\003\000\002\025" +
    "\003\000\002\025\003\000\002\034\004\000\002\031\004" +
    "\000\002\031\005\000\002\031\003\000\002\031\005\000" +
    "\002\026\005\000\002\026\003\000\002\026\003\000\002" +
    "\026\005\000\002\020\003\000\002\020\004\000\002\023" +
    "\005\000\002\047\006\000\002\021\007\000\002\022\005" +
    "\000\002\024\003\000\002\024\003\000\002\024\003\000" +
    "\002\003\006\000\002\003\002\000\002\054\006\000\002" +
    "\055\004\000\002\055\003\000\002\055\005\000\002\062" +
    "\002\000\002\063\002\000\002\030\014\000\002\064\002" +
    "\000\002\065\002\000\002\030\011\000\002\066\002\000" +
    "\002\036\007\000\002\037\003\000\002\037\002\000\002" +
    "\032\007\000\002\032\006\000\002\067\002\000\002\033" +
    "\013\000\002\070\002\000\002\071\002\000\002\033\012" +
    "\000\002\050\005\000\002\050\002\000\002\040\003\000" +
    "\002\040\003\000\002\040\003\000\002\040\004\000\002" +
    "\040\003\000\002\041\004\000\002\041\003\000\002\041" +
    "\002\000\002\053\003\000\002\053\003\000\002\053\003" +
    "\000\002\045\003\000\002\045\003\000\002\046\003\000" +
    "\002\046\003\000\002\046\003\000\002\046\003\000\002" +
    "\046\003\000\002\046\003\000\002\046\003\000\002\046" +
    "\003\000\002\046\003\000\002\072\002\000\002\051\012" +
    "\000\002\073\002\000\002\074\002\000\002\051\011\000" +
    "\002\075\002\000\002\052\016\000\002\076\002\000\002" +
    "\077\002\000\002\052\011\000\002\002\003\000\002\002" +
    "\002" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\343\000\020\002\uff7d\003\013\005\004\006\014\007" +
    "\005\010\015\011\011\001\002\000\006\004\000\065\000" +
    "\001\002\000\006\004\ufffe\065\ufffe\001\002\000\020\002" +
    "\uffdf\003\013\005\004\006\014\007\005\010\015\011\011" +
    "\001\002\000\004\002\344\001\002\000\004\002\uff7e\001" +
    "\002\000\006\004\ufffc\065\ufffc\001\002\000\006\004\017" +
    "\065\020\001\002\000\004\002\uffdd\001\002\000\006\004" +
    "\uffff\065\uffff\001\002\000\006\004\ufffd\065\ufffd\001\002" +
    "\000\004\025\021\001\002\000\004\025\ufff6\001\002\000" +
    "\004\025\ufff5\001\002\000\020\003\uffe2\005\uffe5\006\uffe5" +
    "\007\uffe5\010\uffe5\011\uffe5\026\uffe5\001\002\000\004\003" +
    "\336\001\002\000\016\005\004\006\014\007\005\010\015" +
    "\011\011\026\uffe6\001\002\000\004\026\032\001\002\000" +
    "\004\065\027\001\002\000\004\026\uffe7\001\002\000\006" +
    "\022\030\026\uffe8\001\002\000\014\005\004\006\014\007" +
    "\005\010\015\011\011\001\002\000\004\026\uffe9\001\002" +
    "\000\004\017\uffe4\001\002\000\004\017\034\001\002\000" +
    "\046\003\053\004\017\005\004\006\014\007\005\010\015" +
    "\011\011\020\uff97\021\uffdc\051\050\053\062\054\040\055" +
    "\056\060\054\061\052\063\067\064\061\065\072\001\002" +
    "\000\004\021\335\001\002\000\004\021\uffb8\001\002\000" +
    "\052\003\053\004\017\005\004\006\014\007\005\010\015" +
    "\011\011\020\uff97\021\uffdc\051\050\053\062\054\040\055" +
    "\056\056\uff97\057\uff97\060\054\061\052\063\067\064\061" +
    "\065\072\001\002\000\006\003\303\025\304\001\002\000" +
    "\052\003\uff9a\004\uff9a\005\uff9a\006\uff9a\007\uff9a\010\uff9a" +
    "\011\uff9a\020\uff9a\021\uff9a\051\uff9a\053\uff9a\054\uff9a\055" +
    "\uff9a\056\uff9a\057\uff9a\060\uff9a\061\uff9a\063\uff9a\064\uff9a" +
    "\065\uff9a\001\002\000\004\025\300\001\002\000\004\021" +
    "\uff8f\001\002\000\004\021\uff90\001\002\000\052\003\uff9c" +
    "\004\uff9c\005\uff9c\006\uff9c\007\uff9c\010\uff9c\011\uff9c\020" +
    "\uff9c\021\uff9c\051\uff9c\053\uff9c\054\uff9c\055\uff9c\056\uff9c" +
    "\057\uff9c\060\uff9c\061\uff9c\063\uff9c\064\uff9c\065\uff9c\001" +
    "\002\000\004\021\uff8e\001\002\000\004\021\uffb9\001\002" +
    "\000\006\003\253\025\254\001\002\000\004\021\uff91\001" +
    "\002\000\026\004\017\012\113\013\116\014\103\015\112" +
    "\016\115\021\uffda\025\101\050\111\065\102\001\002\000" +
    "\012\020\uff98\021\uff89\056\uff98\057\uff98\001\002\000\004" +
    "\021\uff8c\001\002\000\004\021\uffba\001\002\000\006\003" +
    "\223\025\224\001\002\000\052\003\uff9d\004\uff9d\005\uff9d" +
    "\006\uff9d\007\uff9d\010\uff9d\011\uff9d\020\uff9d\021\uff9d\051" +
    "\uff9d\053\uff9d\054\uff9d\055\uff9d\056\uff9d\057\uff9d\060\uff9d" +
    "\061\uff9d\063\uff9d\064\uff9d\065\uff9d\001\002\000\052\003" +
    "\uff9e\004\uff9e\005\uff9e\006\uff9e\007\uff9e\010\uff9e\011\uff9e" +
    "\020\uff9e\021\uff9e\051\uff9e\053\uff9e\054\uff9e\055\uff9e\056" +
    "\uff9e\057\uff9e\060\uff9e\061\uff9e\063\uff9e\064\uff9e\065\uff9e" +
    "\001\002\000\004\025\220\001\002\000\006\003\203\025" +
    "\204\001\002\000\004\021\uffb3\001\002\000\004\021\uff8d" +
    "\001\002\000\020\027\201\030\127\031\131\032\141\033" +
    "\133\034\130\035\136\001\002\000\004\021\uff8a\001\002" +
    "\000\004\025\175\001\002\000\004\020\174\001\002\000" +
    "\004\021\uff8b\001\002\000\030\023\151\025\ufff5\027\165" +
    "\030\127\031\131\032\141\033\133\034\130\035\136\036" +
    "\154\037\152\001\002\000\004\065\074\001\002\000\010" +
    "\021\uffb4\023\151\027\161\001\002\000\006\021\uffb6\027" +
    "\077\001\002\000\004\021\uffb2\001\002\000\004\017\100" +
    "\001\002\000\024\004\017\012\113\013\116\014\103\015" +
    "\112\016\115\025\101\050\111\065\102\001\002\000\024" +
    "\004\017\012\113\013\116\014\103\015\112\016\115\025" +
    "\101\050\111\065\102\001\002\000\060\020\uffef\021\uffef" +
    "\022\uffef\023\151\024\uffef\025\ufff5\026\uffef\030\uffef\031" +
    "\uffef\032\uffef\033\uffef\034\uffef\035\uffef\036\154\037\152" +
    "\040\uffef\041\uffef\042\uffef\043\uffef\044\uffef\045\uffef\046" +
    "\uffef\047\uffef\001\002\000\052\020\ufff9\021\ufff9\022\ufff9" +
    "\024\ufff9\026\ufff9\030\ufff9\031\ufff9\032\ufff9\033\ufff9\034" +
    "\ufff9\035\ufff9\040\ufff9\041\ufff9\042\ufff9\043\ufff9\044\ufff9" +
    "\045\ufff9\046\ufff9\047\ufff9\062\ufff9\001\002\000\044\020" +
    "\uffea\022\147\026\uffea\030\127\031\131\032\141\033\133" +
    "\034\130\035\136\040\123\041\140\042\125\043\134\044" +
    "\137\045\126\046\132\047\142\001\002\000\050\020\uffed" +
    "\021\uffed\022\uffed\024\uffed\026\uffed\030\uffed\031\uffed\032" +
    "\uffed\033\uffed\034\uffed\035\uffed\040\uffed\041\uffed\042\uffed" +
    "\043\uffed\044\uffed\045\uffed\046\uffed\047\uffed\001\002\000" +
    "\050\020\uffc3\021\uffc3\022\uffc3\024\uffc3\026\uffc3\030\uffc3" +
    "\031\uffc3\032\uffc3\033\uffc3\034\uffc3\035\uffc3\040\uffc3\041" +
    "\uffc3\042\uffc3\043\uffc3\044\uffc3\045\uffc3\046\uffc3\047\uffc3" +
    "\001\002\000\004\020\146\001\002\000\050\020\uffee\021" +
    "\uffee\022\uffee\024\uffee\026\uffee\030\uffee\031\uffee\032\uffee" +
    "\033\uffee\034\uffee\035\uffee\040\uffee\041\uffee\042\uffee\043" +
    "\uffee\044\uffee\045\uffee\046\uffee\047\uffee\001\002\000\024" +
    "\004\017\012\113\013\116\014\103\015\112\016\115\025" +
    "\101\050\111\065\102\001\002\000\052\020\ufff8\021\ufff8" +
    "\022\ufff8\024\ufff8\026\ufff8\030\ufff8\031\ufff8\032\ufff8\033" +
    "\ufff8\034\ufff8\035\ufff8\040\ufff8\041\ufff8\042\ufff8\043\ufff8" +
    "\044\ufff8\045\ufff8\046\ufff8\047\ufff8\062\ufff8\001\002\000" +
    "\052\020\ufffb\021\ufffb\022\ufffb\024\ufffb\026\ufffb\030\ufffb" +
    "\031\ufffb\032\ufffb\033\ufffb\034\ufffb\035\ufffb\040\ufffb\041" +
    "\ufffb\042\ufffb\043\ufffb\044\ufffb\045\ufffb\046\ufffb\047\ufffb" +
    "\062\ufffb\001\002\000\050\020\uffec\021\uffec\022\uffec\024" +
    "\uffec\026\uffec\030\uffec\031\uffec\032\uffec\033\uffec\034\uffec" +
    "\035\uffec\040\uffec\041\uffec\042\uffec\043\uffec\044\uffec\045" +
    "\uffec\046\uffec\047\uffec\001\002\000\052\020\ufff7\021\ufff7" +
    "\022\ufff7\024\ufff7\026\ufff7\030\ufff7\031\ufff7\032\ufff7\033" +
    "\ufff7\034\ufff7\035\ufff7\040\ufff7\041\ufff7\042\ufff7\043\ufff7" +
    "\044\ufff7\045\ufff7\046\ufff7\047\ufff7\062\ufff7\001\002\000" +
    "\052\020\ufffa\021\ufffa\022\ufffa\024\ufffa\026\ufffa\030\ufffa" +
    "\031\ufffa\032\ufffa\033\ufffa\034\ufffa\035\ufffa\040\ufffa\041" +
    "\ufffa\042\ufffa\043\ufffa\044\ufffa\045\ufffa\046\ufffa\047\ufffa" +
    "\062\ufffa\001\002\000\050\020\uffc2\021\uffc2\022\uffc2\024" +
    "\uffc2\026\uffc2\030\uffc2\031\uffc2\032\uffc2\033\uffc2\034\uffc2" +
    "\035\uffc2\040\uffc2\041\uffc2\042\uffc2\043\uffc2\044\uffc2\045" +
    "\uffc2\046\uffc2\047\uffc2\001\002\000\050\020\uffc6\021\uffc6" +
    "\022\uffc6\024\uffc6\026\uffc6\030\uffc6\031\uffc6\032\uffc6\033" +
    "\uffc6\034\uffc6\035\uffc6\040\uffc6\041\uffc6\042\uffc6\043\uffc6" +
    "\044\uffc6\045\uffc6\046\uffc6\047\uffc6\001\002\000\050\020" +
    "\uffc8\021\uffc8\022\uffc8\024\uffc8\026\uffc8\030\uffc8\031\uffc8" +
    "\032\uffc8\033\uffc8\034\uffc8\035\uffc8\040\123\041\140\042" +
    "\125\043\134\044\137\045\126\046\uffc8\047\uffc8\001\002" +
    "\000\024\004\017\012\113\013\116\014\103\015\112\016" +
    "\115\025\101\050\111\065\102\001\002\000\024\004\uffcd" +
    "\012\uffcd\013\uffcd\014\uffcd\015\uffcd\016\uffcd\025\uffcd\050" +
    "\uffcd\065\uffcd\001\002\000\024\004\017\012\113\013\116" +
    "\014\103\015\112\016\115\025\101\050\111\065\102\001" +
    "\002\000\024\004\uffcc\012\uffcc\013\uffcc\014\uffcc\015\uffcc" +
    "\016\uffcc\025\uffcc\050\uffcc\065\uffcc\001\002\000\024\004" +
    "\uffca\012\uffca\013\uffca\014\uffca\015\uffca\016\uffca\025\uffca" +
    "\050\uffca\065\uffca\001\002\000\026\004\uffd9\012\uffd9\013" +
    "\uffd9\014\uffd9\015\uffd9\016\uffd9\025\uffd9\027\uffd9\050\uffd9" +
    "\065\uffd9\001\002\000\026\004\uffd5\012\uffd5\013\uffd5\014" +
    "\uffd5\015\uffd5\016\uffd5\025\uffd5\027\uffd5\050\uffd5\065\uffd5" +
    "\001\002\000\026\004\uffd8\012\uffd8\013\uffd8\014\uffd8\015" +
    "\uffd8\016\uffd8\025\uffd8\027\uffd8\050\uffd8\065\uffd8\001\002" +
    "\000\024\004\uffd1\012\uffd1\013\uffd1\014\uffd1\015\uffd1\016" +
    "\uffd1\025\uffd1\050\uffd1\065\uffd1\001\002\000\026\004\uffd6" +
    "\012\uffd6\013\uffd6\014\uffd6\015\uffd6\016\uffd6\025\uffd6\027" +
    "\uffd6\050\uffd6\065\uffd6\001\002\000\024\004\uffce\012\uffce" +
    "\013\uffce\014\uffce\015\uffce\016\uffce\025\uffce\050\uffce\065" +
    "\uffce\001\002\000\024\004\017\012\113\013\116\014\103" +
    "\015\112\016\115\025\101\050\111\065\102\001\002\000" +
    "\026\004\uffd4\012\uffd4\013\uffd4\014\uffd4\015\uffd4\016\uffd4" +
    "\025\uffd4\027\uffd4\050\uffd4\065\uffd4\001\002\000\024\004" +
    "\uffcb\012\uffcb\013\uffcb\014\uffcb\015\uffcb\016\uffcb\025\uffcb" +
    "\050\uffcb\065\uffcb\001\002\000\024\004\uffcf\012\uffcf\013" +
    "\uffcf\014\uffcf\015\uffcf\016\uffcf\025\uffcf\050\uffcf\065\uffcf" +
    "\001\002\000\026\004\uffd7\012\uffd7\013\uffd7\014\uffd7\015" +
    "\uffd7\016\uffd7\025\uffd7\027\uffd7\050\uffd7\065\uffd7\001\002" +
    "\000\024\004\uffd0\012\uffd0\013\uffd0\014\uffd0\015\uffd0\016" +
    "\uffd0\025\uffd0\050\uffd0\065\uffd0\001\002\000\050\020\uffc7" +
    "\021\uffc7\022\uffc7\024\uffc7\026\uffc7\030\127\031\131\032" +
    "\141\033\133\034\130\035\136\040\123\041\140\042\125" +
    "\043\134\044\137\045\126\046\132\047\142\001\002\000" +
    "\050\020\uffc4\021\uffc4\022\uffc4\024\uffc4\026\uffc4\030\127" +
    "\031\131\032\141\033\133\034\130\035\136\040\123\041" +
    "\140\042\125\043\134\044\137\045\126\046\132\047\142" +
    "\001\002\000\050\020\uffc1\021\uffc1\022\uffc1\024\uffc1\026" +
    "\uffc1\030\127\031\131\032\141\033\133\034\130\035\136" +
    "\040\123\041\140\042\125\043\134\044\137\045\126\046" +
    "\132\047\142\001\002\000\004\021\uffb7\001\002\000\024" +
    "\004\017\012\113\013\116\014\103\015\112\016\115\025" +
    "\101\050\111\065\102\001\002\000\006\020\uffeb\026\uffeb" +
    "\001\002\000\024\004\017\012\113\013\116\014\103\015" +
    "\112\016\115\025\101\050\111\065\102\001\002\000\050" +
    "\020\uffd2\021\uffd2\022\uffd2\024\uffd2\026\uffd2\030\uffd2\031" +
    "\uffd2\032\uffd2\033\uffd2\034\uffd2\035\uffd2\040\uffd2\041\uffd2" +
    "\042\uffd2\043\uffd2\044\uffd2\045\uffd2\046\uffd2\047\uffd2\001" +
    "\002\000\050\020\uffc9\021\uffc9\022\uffc9\024\uffc9\026\uffc9" +
    "\030\uffc9\031\uffc9\032\uffc9\033\uffc9\034\uffc9\035\uffc9\040" +
    "\uffc9\041\uffc9\042\uffc9\043\uffc9\044\uffc9\045\uffc9\046\uffc9" +
    "\047\uffc9\001\002\000\050\020\uffd3\021\uffd3\022\uffd3\024" +
    "\uffd3\026\uffd3\030\uffd3\031\uffd3\032\uffd3\033\uffd3\034\uffd3" +
    "\035\uffd3\040\uffd3\041\uffd3\042\uffd3\043\uffd3\044\uffd3\045" +
    "\uffd3\046\uffd3\047\uffd3\001\002\000\040\024\156\030\127" +
    "\031\131\032\141\033\133\034\130\035\136\040\123\041" +
    "\140\042\125\043\134\044\137\045\126\046\132\047\142" +
    "\001\002\000\052\020\uffbd\021\uffbd\022\uffbd\024\uffbd\026" +
    "\uffbd\027\uffbd\030\uffbd\031\uffbd\032\uffbd\033\uffbd\034\uffbd" +
    "\035\uffbd\040\uffbd\041\uffbd\042\uffbd\043\uffbd\044\uffbd\045" +
    "\uffbd\046\uffbd\047\uffbd\001\002\000\040\026\160\030\127" +
    "\031\131\032\141\033\133\034\130\035\136\040\123\041" +
    "\140\042\125\043\134\044\137\045\126\046\132\047\142" +
    "\001\002\000\050\020\uffc5\021\uffc5\022\uffc5\024\uffc5\026" +
    "\uffc5\030\uffc5\031\uffc5\032\uffc5\033\uffc5\034\uffc5\035\uffc5" +
    "\040\uffc5\041\uffc5\042\uffc5\043\uffc5\044\uffc5\045\uffc5\046" +
    "\uffc5\047\uffc5\001\002\000\024\004\017\012\113\013\116" +
    "\014\103\015\112\016\115\025\101\050\111\065\102\001" +
    "\002\000\044\021\uffb5\022\uffb5\026\uffb5\030\127\031\131" +
    "\032\141\033\133\034\130\035\136\040\123\041\140\042" +
    "\125\043\134\044\137\045\126\046\132\047\142\001\002" +
    "\000\004\027\173\001\002\000\024\004\017\012\113\013" +
    "\116\014\103\015\112\016\115\025\101\050\111\065\102" +
    "\001\002\000\026\004\uffc0\012\uffc0\013\uffc0\014\uffc0\015" +
    "\uffc0\016\uffc0\017\166\025\uffc0\050\uffc0\065\uffc0\001\002" +
    "\000\026\004\017\012\113\013\116\014\103\015\112\016" +
    "\115\020\ufff0\025\101\050\111\065\102\001\002\000\006" +
    "\020\ufff1\026\ufff1\001\002\000\004\020\171\001\002\000" +
    "\004\021\uffbc\001\002\000\042\021\uffbe\022\uffbe\030\127" +
    "\031\131\032\141\033\133\034\130\035\136\040\123\041" +
    "\140\042\125\043\134\044\137\045\126\046\132\047\142" +
    "\001\002\000\024\004\uffbf\012\uffbf\013\uffbf\014\uffbf\015" +
    "\uffbf\016\uffbf\025\uffbf\050\uffbf\065\uffbf\001\002\000\020" +
    "\002\uffe3\003\uffe3\005\uffe3\006\uffe3\007\uffe3\010\uffe3\011" +
    "\uffe3\001\002\000\024\004\017\012\113\013\116\014\103" +
    "\015\112\016\115\025\101\050\111\065\102\001\002\000" +
    "\040\026\177\030\127\031\131\032\141\033\133\034\130" +
    "\035\136\040\123\041\140\042\125\043\134\044\137\045" +
    "\126\046\132\047\142\001\002\000\004\021\ufff2\001\002" +
    "\000\024\004\017\012\113\013\116\014\103\015\112\016" +
    "\115\025\101\050\111\065\102\001\002\000\024\004\uffc0" +
    "\012\uffc0\013\uffc0\014\uffc0\015\uffc0\016\uffc0\025\uffc0\050" +
    "\uffc0\065\uffc0\001\002\000\040\021\uffbb\030\127\031\131" +
    "\032\141\033\133\034\130\035\136\040\123\041\140\042" +
    "\125\043\134\044\137\045\126\046\132\047\142\001\002" +
    "\000\004\017\uff86\001\002\000\024\004\017\012\113\013" +
    "\116\014\103\015\112\016\115\025\101\050\111\065\102" +
    "\001\002\000\040\026\206\030\127\031\131\032\141\033" +
    "\133\034\130\035\136\040\123\041\140\042\125\043\134" +
    "\044\137\045\126\046\132\047\142\001\002\000\004\017" +
    "\207\001\002\000\046\003\uff88\004\uff88\005\uff88\006\uff88" +
    "\007\uff88\010\uff88\011\uff88\020\uff88\021\uff88\051\uff88\053" +
    "\uff88\054\uff88\055\uff88\060\uff88\061\uff88\063\uff88\064\uff88" +
    "\065\uff88\001\002\000\046\003\053\004\017\005\004\006" +
    "\014\007\005\010\015\011\011\020\uff97\021\uffdc\051\050" +
    "\053\062\054\040\055\056\060\054\061\052\063\067\064" +
    "\061\065\072\001\002\000\004\020\212\001\002\000\052" +
    "\003\uff87\004\uff87\005\uff87\006\uff87\007\uff87\010\uff87\011" +
    "\uff87\020\uff87\021\uff87\051\uff87\053\uff87\054\uff87\055\uff87" +
    "\056\uff87\057\uff87\060\uff87\061\uff87\063\uff87\064\uff87\065" +
    "\uff87\001\002\000\004\017\214\001\002\000\046\003\uff85" +
    "\004\uff85\005\uff85\006\uff85\007\uff85\010\uff85\011\uff85\020" +
    "\uff85\021\uff85\051\uff85\053\uff85\054\uff85\055\uff85\060\uff85" +
    "\061\uff85\063\uff85\064\uff85\065\uff85\001\002\000\046\003" +
    "\053\004\017\005\004\006\014\007\005\010\015\011\011" +
    "\020\uff97\021\uffdc\051\050\053\062\054\040\055\056\060" +
    "\054\061\052\063\067\064\061\065\072\001\002\000\004" +
    "\020\217\001\002\000\052\003\uff84\004\uff84\005\uff84\006" +
    "\uff84\007\uff84\010\uff84\011\uff84\020\uff84\021\uff84\051\uff84" +
    "\053\uff84\054\uff84\055\uff84\056\uff84\057\uff84\060\uff84\061" +
    "\uff84\063\uff84\064\uff84\065\uff84\001\002\000\004\065\221" +
    "\001\002\000\004\026\222\001\002\000\004\021\ufff3\001" +
    "\002\000\004\017\uffa3\001\002\000\024\004\017\012\113" +
    "\013\116\014\103\015\112\016\115\025\101\050\111\065" +
    "\102\001\002\000\040\026\226\030\127\031\131\032\141" +
    "\033\133\034\130\035\136\040\123\041\140\042\125\043" +
    "\134\044\137\045\126\046\132\047\142\001\002\000\004" +
    "\017\227\001\002\000\004\056\uffa5\001\002\000\004\056" +
    "\232\001\002\000\006\020\uff9f\057\237\001\002\000\014" +
    "\012\113\013\116\014\103\015\112\016\115\001\002\000" +
    "\004\062\234\001\002\000\052\003\053\004\017\005\004" +
    "\006\014\007\005\010\015\011\011\020\uff97\021\uffdc\051" +
    "\050\053\062\054\040\055\056\056\uff97\057\uff97\060\054" +
    "\061\052\063\067\064\061\065\072\001\002\000\010\020" +
    "\uffa6\056\232\057\uffa6\001\002\000\006\020\uffa7\057\uffa7" +
    "\001\002\000\004\062\242\001\002\000\004\020\241\001" +
    "\002\000\052\003\uffa4\004\uffa4\005\uffa4\006\uffa4\007\uffa4" +
    "\010\uffa4\011\uffa4\020\uffa4\021\uffa4\051\uffa4\053\uffa4\054" +
    "\uffa4\055\uffa4\056\uffa4\057\uffa4\060\uffa4\061\uffa4\063\uffa4" +
    "\064\uffa4\065\uffa4\001\002\000\046\003\053\004\017\005" +
    "\004\006\014\007\005\010\015\011\011\020\uff97\021\uffdc" +
    "\051\050\053\062\054\040\055\056\060\054\061\052\063" +
    "\067\064\061\065\072\001\002\000\004\020\uffa0\001\002" +
    "\000\004\017\245\001\002\000\004\056\uffa2\001\002\000" +
    "\004\056\232\001\002\000\006\020\uff9f\057\237\001\002" +
    "\000\004\020\251\001\002\000\052\003\uffa1\004\uffa1\005" +
    "\uffa1\006\uffa1\007\uffa1\010\uffa1\011\uffa1\020\uffa1\021\uffa1" +
    "\051\uffa1\053\uffa1\054\uffa1\055\uffa1\056\uffa1\057\uffa1\060" +
    "\uffa1\061\uffa1\063\uffa1\064\uffa1\065\uffa1\001\002\000\040" +
    "\021\uffdb\030\127\031\131\032\141\033\133\034\130\035" +
    "\136\040\123\041\140\042\125\043\134\044\137\045\126" +
    "\046\132\047\142\001\002\000\004\017\uffae\001\002\000" +
    "\024\004\017\012\113\013\116\014\103\015\112\016\115" +
    "\025\101\050\111\065\102\001\002\000\040\026\256\030" +
    "\127\031\131\032\141\033\133\034\130\035\136\040\123" +
    "\041\140\042\125\043\134\044\137\045\126\046\132\047" +
    "\142\001\002\000\004\017\257\001\002\000\046\003\uffb1" +
    "\004\uffb1\005\uffb1\006\uffb1\007\uffb1\010\uffb1\011\uffb1\020" +
    "\uffb1\021\uffb1\051\uffb1\053\uffb1\054\uffb1\055\uffb1\060\uffb1" +
    "\061\uffb1\063\uffb1\064\uffb1\065\uffb1\001\002\000\046\003" +
    "\053\004\017\005\004\006\014\007\005\010\015\011\011" +
    "\020\uff97\021\uffdc\051\050\053\062\054\040\055\056\060" +
    "\054\061\052\063\067\064\061\065\072\001\002\000\004" +
    "\020\262\001\002\000\054\003\uffb0\004\uffb0\005\uffb0\006" +
    "\uffb0\007\uffb0\010\uffb0\011\uffb0\020\uffb0\021\uffb0\051\uffb0" +
    "\052\uffb0\053\uffb0\054\uffb0\055\uffb0\056\uffb0\057\uffb0\060" +
    "\uffb0\061\uffb0\063\uffb0\064\uffb0\065\uffb0\001\002\000\054" +
    "\003\uffa8\004\uffa8\005\uffa8\006\uffa8\007\uffa8\010\uffa8\011" +
    "\uffa8\020\uffa8\021\uffa8\051\uffa8\052\266\053\uffa8\054\uffa8" +
    "\055\uffa8\056\uffa8\057\uffa8\060\uffa8\061\uffa8\063\uffa8\064" +
    "\uffa8\065\uffa8\001\002\000\052\003\uffaf\004\uffaf\005\uffaf" +
    "\006\uffaf\007\uffaf\010\uffaf\011\uffaf\020\uffaf\021\uffaf\051" +
    "\uffaf\053\uffaf\054\uffaf\055\uffaf\056\uffaf\057\uffaf\060\uffaf" +
    "\061\uffaf\063\uffaf\064\uffaf\065\uffaf\001\002\000\052\003" +
    "\uffa9\004\uffa9\005\uffa9\006\uffa9\007\uffa9\010\uffa9\011\uffa9" +
    "\020\uffa9\021\uffa9\051\uffa9\053\uffa9\054\uffa9\055\uffa9\056" +
    "\uffa9\057\uffa9\060\uffa9\061\uffa9\063\uffa9\064\uffa9\065\uffa9" +
    "\001\002\000\004\017\267\001\002\000\046\003\uffab\004" +
    "\uffab\005\uffab\006\uffab\007\uffab\010\uffab\011\uffab\020\uffab" +
    "\021\uffab\051\uffab\053\uffab\054\uffab\055\uffab\060\uffab\061" +
    "\uffab\063\uffab\064\uffab\065\uffab\001\002\000\046\003\053" +
    "\004\017\005\004\006\014\007\005\010\015\011\011\020" +
    "\uff97\021\uffdc\051\050\053\062\054\040\055\056\060\054" +
    "\061\052\063\067\064\061\065\072\001\002\000\004\020" +
    "\272\001\002\000\052\003\uffaa\004\uffaa\005\uffaa\006\uffaa" +
    "\007\uffaa\010\uffaa\011\uffaa\020\uffaa\021\uffaa\051\uffaa\053" +
    "\uffaa\054\uffaa\055\uffaa\056\uffaa\057\uffaa\060\uffaa\061\uffaa" +
    "\063\uffaa\064\uffaa\065\uffaa\001\002\000\004\017\274\001" +
    "\002\000\046\003\uffad\004\uffad\005\uffad\006\uffad\007\uffad" +
    "\010\uffad\011\uffad\020\uffad\021\uffad\051\uffad\053\uffad\054" +
    "\uffad\055\uffad\060\uffad\061\uffad\063\uffad\064\uffad\065\uffad" +
    "\001\002\000\046\003\053\004\017\005\004\006\014\007" +
    "\005\010\015\011\011\020\uff97\021\uffdc\051\050\053\062" +
    "\054\040\055\056\060\054\061\052\063\067\064\061\065" +
    "\072\001\002\000\004\020\277\001\002\000\052\003\uffac" +
    "\004\uffac\005\uffac\006\uffac\007\uffac\010\uffac\011\uffac\020" +
    "\uffac\021\uffac\051\uffac\053\uffac\054\uffac\055\uffac\056\uffac" +
    "\057\uffac\060\uffac\061\uffac\063\uffac\064\uffac\065\uffac\001" +
    "\002\000\026\004\017\012\113\013\116\014\103\015\112" +
    "\016\115\025\101\026\ufff0\050\111\065\102\001\002\000" +
    "\004\026\302\001\002\000\050\020\ufff4\021\ufff4\022\ufff4" +
    "\024\ufff4\026\ufff4\030\ufff4\031\ufff4\032\ufff4\033\ufff4\034" +
    "\ufff4\035\ufff4\040\ufff4\041\ufff4\042\ufff4\043\ufff4\044\ufff4" +
    "\045\ufff4\046\ufff4\047\ufff4\001\002\000\004\017\uff81\001" +
    "\002\000\016\005\uff83\006\uff83\007\uff83\010\uff83\011\uff83" +
    "\065\uff83\001\002\000\016\005\004\006\014\007\005\010" +
    "\015\011\011\065\311\001\002\000\004\022\uff94\001\002" +
    "\000\004\065\326\001\002\000\004\022\313\001\002\000" +
    "\022\022\uff95\027\201\030\127\031\131\032\141\033\133" +
    "\034\130\035\136\001\002\000\004\022\uff96\001\002\000" +
    "\024\004\017\012\113\013\116\014\103\015\112\016\115" +
    "\025\101\050\111\065\102\001\002\000\040\022\315\030" +
    "\127\031\131\032\141\033\133\034\130\035\136\040\123" +
    "\041\140\042\125\043\134\044\137\045\126\046\132\047" +
    "\142\001\002\000\016\005\004\006\014\007\005\010\015" +
    "\011\011\065\321\001\002\000\004\026\322\001\002\000" +
    "\004\026\uff92\001\002\000\004\026\uff93\001\002\000\006" +
    "\036\154\037\152\001\002\000\004\017\323\001\002\000" +
    "\046\003\053\004\017\005\004\006\014\007\005\010\015" +
    "\011\011\020\uff97\021\uffdc\051\050\053\062\054\040\055" +
    "\056\060\054\061\052\063\067\064\061\065\072\001\002" +
    "\000\004\020\325\001\002\000\052\003\uff82\004\uff82\005" +
    "\uff82\006\uff82\007\uff82\010\uff82\011\uff82\020\uff82\021\uff82" +
    "\051\uff82\053\uff82\054\uff82\055\uff82\056\uff82\057\uff82\060" +
    "\uff82\061\uff82\063\uff82\064\uff82\065\uff82\001\002\000\004" +
    "\027\161\001\002\000\004\017\330\001\002\000\046\003" +
    "\uff80\004\uff80\005\uff80\006\uff80\007\uff80\010\uff80\011\uff80" +
    "\020\uff80\021\uff80\051\uff80\053\uff80\054\uff80\055\uff80\060" +
    "\uff80\061\uff80\063\uff80\064\uff80\065\uff80\001\002\000\046" +
    "\003\053\004\017\005\004\006\014\007\005\010\015\011" +
    "\011\020\uff97\021\uffdc\051\050\053\062\054\040\055\056" +
    "\060\054\061\052\063\067\064\061\065\072\001\002\000" +
    "\004\020\333\001\002\000\052\003\uff7f\004\uff7f\005\uff7f" +
    "\006\uff7f\007\uff7f\010\uff7f\011\uff7f\020\uff7f\021\uff7f\051" +
    "\uff7f\053\uff7f\054\uff7f\055\uff7f\056\uff7f\057\uff7f\060\uff7f" +
    "\061\uff7f\063\uff7f\064\uff7f\065\uff7f\001\002\000\010\020" +
    "\uff99\056\uff99\057\uff99\001\002\000\052\003\uff9b\004\uff9b" +
    "\005\uff9b\006\uff9b\007\uff9b\010\uff9b\011\uff9b\020\uff9b\021" +
    "\uff9b\051\uff9b\053\uff9b\054\uff9b\055\uff9b\056\uff9b\057\uff9b" +
    "\060\uff9b\061\uff9b\063\uff9b\064\uff9b\065\uff9b\001\002\000" +
    "\004\026\337\001\002\000\004\017\uffe1\001\002\000\004" +
    "\017\341\001\002\000\046\003\053\004\017\005\004\006" +
    "\014\007\005\010\015\011\011\020\uff97\021\uffdc\051\050" +
    "\053\062\054\040\055\056\060\054\061\052\063\067\064" +
    "\061\065\072\001\002\000\004\020\343\001\002\000\020" +
    "\002\uffe0\003\uffe0\005\uffe0\006\uffe0\007\uffe0\010\uffe0\011" +
    "\uffe0\001\002\000\004\002\001\001\002\000\004\002\uffde" +
    "\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\343\000\012\002\006\012\011\042\005\043\007\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\012\011" +
    "\042\005\043\344\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\005\015\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\056\022" +
    "\060\021\001\001\000\002\001\001\000\010\004\025\006" +
    "\023\012\024\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\004\030\012" +
    "\024\001\001\000\002\001\001\000\004\057\032\001\001" +
    "\000\002\001\001\000\054\005\041\012\072\014\070\016" +
    "\063\017\045\021\035\022\054\023\046\024\042\030\057" +
    "\033\040\034\050\040\036\041\067\044\065\046\034\047" +
    "\064\051\056\052\044\054\062\055\043\001\001\000\002" +
    "\001\001\000\002\001\001\000\054\005\041\012\072\014" +
    "\070\016\063\017\045\021\035\022\054\023\046\024\042" +
    "\030\057\033\040\034\050\040\036\041\333\044\065\046" +
    "\034\047\064\051\056\052\044\054\062\055\043\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\022\005\041\010\116\013\107\014\104\026\117" +
    "\031\251\034\105\047\113\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\020\177" +
    "\035\162\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\015\152\020\163" +
    "\035\162\001\001\000\004\047\074\001\001\000\002\001" +
    "\001\000\004\003\075\001\001\000\002\001\001\000\002" +
    "\001\001\000\024\005\041\010\116\011\106\013\107\014" +
    "\104\026\117\031\103\034\105\047\113\001\001\000\022" +
    "\005\041\010\116\013\107\014\104\026\117\031\156\034" +
    "\105\047\113\001\001\000\004\015\152\001\001\000\002" +
    "\001\001\000\010\025\123\027\134\035\121\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\022\005\041\010\116\013\107\014\104\026" +
    "\117\031\120\034\105\047\113\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\025\123\027\134\035\121\001\001\000\022\005\041\010" +
    "\116\013\107\014\104\026\117\031\144\034\105\047\113" +
    "\001\001\000\002\001\001\000\022\005\041\010\116\013" +
    "\107\014\104\026\117\031\143\034\105\047\113\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\022\005\041\010\116\013" +
    "\107\014\104\026\117\031\142\034\105\047\113\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\025\123\027\134" +
    "\035\121\001\001\000\010\025\123\027\134\035\121\001" +
    "\001\000\010\025\123\027\134\035\121\001\001\000\002" +
    "\001\001\000\024\005\041\010\116\011\147\013\107\014" +
    "\104\026\117\031\103\034\105\047\113\001\001\000\002" +
    "\001\001\000\022\005\041\010\116\013\107\014\104\026" +
    "\117\031\154\034\105\047\113\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\010\025\123\027" +
    "\134\035\121\001\001\000\002\001\001\000\010\025\123" +
    "\027\134\035\121\001\001\000\002\001\001\000\022\005" +
    "\041\010\116\013\107\014\104\026\117\031\161\034\105" +
    "\047\113\001\001\000\010\025\123\027\134\035\121\001" +
    "\001\000\002\001\001\000\022\005\041\010\116\013\107" +
    "\014\104\026\117\031\171\034\105\047\113\001\001\000" +
    "\002\001\001\000\026\005\041\007\167\010\116\011\166" +
    "\013\107\014\104\026\117\031\103\034\105\047\113\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\025\123\027\134\035\121\001\001\000\002\001" +
    "\001\000\002\001\001\000\022\005\041\010\116\013\107" +
    "\014\104\026\117\031\175\034\105\047\113\001\001\000" +
    "\010\025\123\027\134\035\121\001\001\000\002\001\001" +
    "\000\022\005\041\010\116\013\107\014\104\026\117\031" +
    "\201\034\105\047\113\001\001\000\002\001\001\000\010" +
    "\025\123\027\134\035\121\001\001\000\004\073\212\001" +
    "\001\000\022\005\041\010\116\013\107\014\104\026\117" +
    "\031\204\034\105\047\113\001\001\000\010\025\123\027" +
    "\134\035\121\001\001\000\002\001\001\000\004\072\207" +
    "\001\001\000\054\005\041\012\072\014\070\016\063\017" +
    "\045\021\035\022\054\023\046\024\042\030\057\033\040" +
    "\034\050\040\036\041\210\044\065\046\034\047\064\051" +
    "\056\052\044\054\062\055\043\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\074\214\001" +
    "\001\000\054\005\041\012\072\014\070\016\063\017\045" +
    "\021\035\022\054\023\046\024\042\030\057\033\040\034" +
    "\050\040\036\041\215\044\065\046\034\047\064\051\056" +
    "\052\044\054\062\055\043\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\070\243\001\001\000\022\005\041\010" +
    "\116\013\107\014\104\026\117\031\224\034\105\047\113" +
    "\001\001\000\010\025\123\027\134\035\121\001\001\000" +
    "\002\001\001\000\004\067\227\001\001\000\004\032\230" +
    "\001\001\000\004\050\237\001\001\000\004\013\232\001" +
    "\001\000\002\001\001\000\054\005\041\012\072\014\070" +
    "\016\063\017\045\021\035\022\054\023\046\024\042\030" +
    "\057\033\040\034\050\040\036\041\234\044\065\046\034" +
    "\047\064\051\056\052\044\054\062\055\043\001\001\000" +
    "\004\032\235\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\054\005\041\012" +
    "\072\014\070\016\063\017\045\021\035\022\054\023\046" +
    "\024\042\030\057\033\040\034\050\040\036\041\242\044" +
    "\065\046\034\047\064\051\056\052\044\054\062\055\043" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\071" +
    "\245\001\001\000\004\032\246\001\001\000\004\050\247" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\025" +
    "\123\027\134\035\121\001\001\000\004\064\272\001\001" +
    "\000\022\005\041\010\116\013\107\014\104\026\117\031" +
    "\254\034\105\047\113\001\001\000\010\025\123\027\134" +
    "\035\121\001\001\000\002\001\001\000\004\062\257\001" +
    "\001\000\054\005\041\012\072\014\070\016\063\017\045" +
    "\021\035\022\054\023\046\024\042\030\057\033\040\034" +
    "\050\040\036\041\260\044\065\046\034\047\064\051\056" +
    "\052\044\054\062\055\043\001\001\000\002\001\001\000" +
    "\004\063\262\001\001\000\006\036\264\037\263\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\066\267\001\001\000\054\005\041\012\072\014\070" +
    "\016\063\017\045\021\035\022\054\023\046\024\042\030" +
    "\057\033\040\034\050\040\036\041\270\044\065\046\034" +
    "\047\064\051\056\052\044\054\062\055\043\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\065\274\001\001\000\054\005\041\012\072\014\070\016" +
    "\063\017\045\021\035\022\054\023\046\024\042\030\057" +
    "\033\040\034\050\040\036\041\275\044\065\046\034\047" +
    "\064\051\056\052\044\054\062\055\043\001\001\000\002" +
    "\001\001\000\002\001\001\000\026\005\041\007\300\010" +
    "\116\011\166\013\107\014\104\026\117\031\103\034\105" +
    "\047\113\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\076\326\001\001\000\004\075\304\001\001\000\012" +
    "\012\306\023\311\053\307\054\305\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\020\163" +
    "\035\162\001\001\000\002\001\001\000\022\005\041\010" +
    "\116\013\107\014\104\026\117\031\313\034\105\047\113" +
    "\001\001\000\010\025\123\027\134\035\121\001\001\000" +
    "\012\012\306\034\317\045\315\054\316\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\015" +
    "\152\001\001\000\002\001\001\000\054\005\041\012\072" +
    "\014\070\016\063\017\045\021\035\022\054\023\046\024" +
    "\042\030\057\033\040\034\050\040\036\041\323\044\065" +
    "\046\034\047\064\051\056\052\044\054\062\055\043\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\077\330\001\001\000\054\005" +
    "\041\012\072\014\070\016\063\017\045\021\035\022\054" +
    "\023\046\024\042\030\057\033\040\034\050\040\036\041" +
    "\331\044\065\046\034\047\064\051\056\052\044\054\062" +
    "\055\043\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\061\337\001\001\000\002\001\001\000\054\005\041\012" +
    "\072\014\070\016\063\017\045\021\035\022\054\023\046" +
    "\024\042\030\057\033\040\034\050\040\036\041\341\044" +
    "\065\046\034\047\064\051\056\052\044\054\062\055\043" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

    Symbol token = lex.next_token();
    if (token.sym == sym.EOF) {
            return token;
        }
    System.out.println("Parseando token: " + token.sym + " (" + (token.sym >=0 ? sym.terminalNames[token.sym]: "ERROR") + ")"
    + " [Fila: " + token.left + ", Columna: " + token.right + "]");
    return token;

    }


    private LexerCupV lex;
    private SymbolTable symTable;
    private BufferedWriter errorOutputFile;
    private BufferedWriter symTableOutFile;
    private BufferedWriter semanticOutFile;
    private MIPS mipsGenerator;


    public Parser(LexerCupV lexer, BufferedWriter output, BufferedWriter symTableOut, BufferedWriter semanticOut, MIPS mipsGenerator) {
        this.lex = lexer;
        this.errorOutputFile = output;
        this.symTableOutFile = symTableOut;
        this.symTable = new SymbolTable(this.symTableOutFile);
        this.semanticOutFile = semanticOut;
        this.mipsGenerator = mipsGenerator;
    }



    @Override
        /**
        * método para reportar de manera personalizada errores sintácticos al parsear el código fuente
        */
        public void report_error(String message, Object info) {
                    // al sobreescribir este método, lo que conseguimos es que el syntax_error del Parser llame este que estamos
                    // escribiendo y no el que existe por defecto
                    String error = "Error encontrado: " + message;
                    if (info instanceof Symbol) {
                        Symbol symbol = (Symbol) info;
                        error += " en la línea: " + (symbol.left) + ", columna: " + (symbol.right);
                        // se les suma uno porque se almacena iniciando en 0, pero en los archivos siempre lo leemos de 1 en adelante
                    }
                try {
                    this.errorOutputFile.write(error);
                    this.errorOutputFile.newLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                // System.err.println(error);
                }


        public void writeSemanticError(String text) throws IOException {
                if(semanticOutFile != null) {
                    semanticOutFile.write(text + "\n");
                    semanticOutFile.flush();
                }
            }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // type ::= INTEGER 
            {
              Object RESULT =null;
		 RESULT = "INT"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // type ::= FLOAT 
            {
              Object RESULT =null;
		 RESULT = "FLOAT"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // type ::= BOOL 
            {
              Object RESULT =null;
		 RESULT = "BOOL"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // type ::= CHAR 
            {
              Object RESULT =null;
		 RESULT = "CHAR"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // type ::= STRING 
            {
              Object RESULT =null;
		 RESULT = "STRING";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // literal ::= LITERAL_INT 
            {
              Object RESULT =null;
		int intLitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int intLitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object intLit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = "INT"; mipsGenerator.generateLoadImmediate(intLit.toString()); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("literal",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // literal ::= LITERAL_FLOAT 
            {
              Object RESULT =null;
		int fltlitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fltlitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object fltlit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "FLOAT"; mipsGenerator.generateLoadImmediate(fltlit.toString());  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("literal",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // literal ::= LITERAL_BOOL 
            {
              Object RESULT =null;
		int boolLitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int boolLitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object boolLit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = "BOOL"; mipsGenerator.generateLoadImmediate(boolLit.toString()); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("literal",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // literal ::= LITERAL_CHAR 
            {
              Object RESULT =null;
		int chrLitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int chrLitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object chrLit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = "CHAR"; mipsGenerator.generateLoadImmediate(chrLit.toString());
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("literal",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // literal ::= LITERAL_STRING 
            {
              Object RESULT =null;
		int strLitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int strLitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object strLit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = "STRING"; mipsGenerator.declareString(strLit.toString());
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("literal",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // func_name ::= MAIN 
            {
              Object RESULT =null;
		 RESULT = "_verano_";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("func_name",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // func_name ::= IDENTIFIER 
            {
              Object RESULT =null;
		int idFuncleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idFuncright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object idFunc = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = idFunc;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("func_name",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // func_call ::= func_name OPEN_PARENTHESIS arguments CLOSE_PARENTHESIS 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int argleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int argright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object arg = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    // ya no hace falta llamar un método aparte para el tipo de funciones, integramos en uno solo el chequeo de tipos
    RESULT = symTable.getType(f.toString());
    int validationResult = symTable.checkFunctionCall(f.toString(), arg.toString());
    switch (validationResult) {
        case 0:
            // no se hace nada porque la llamada fue exitosa
            System.out.println("llamada exitosa");
            String[] args = arg.toString().split(":");
            mipsGenerator.generateFunctionCall(f.toString(), args);
            break;
        case 1:
            writeSemanticError("Error semantico: la funcion " + f + " no existe. [Fila: " + fleft + ", Col: " + fright + "]");
            break;
        case 2:
            writeSemanticError("Error semantico: no calza la cantidad de argumentos con los parametros definidos. [Fila: "
                + argleft + ", Col: " + argright + "]");
            break;
        case 3:
            writeSemanticError("Error semantico: uno o varios parámetros de " + f
                + " no coincide con el declarado. [Fila: " + argleft + ", Col: " + argright + "]");
            break;
    }
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("func_call",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // read ::= READ OPEN_PARENTHESIS IDENTIFIER CLOSE_PARENTHESIS 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
        if(!symTable.isInsideLocalScope(id.toString())) {
            writeSemanticError("Error semantico: la variable donde se desea guardar el escaneo no esta en el scope. [Fila: "
                + idleft + ", Col: " + idright + "]");
        }
        if(id != null) {
            String readResult = mipsGenerator.generateRead();
            mipsGenerator.generateAssignment(id.toString(), readResult);
        }
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("read",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // print ::= PRINT OPEN_PARENTHESIS log_arith_expression CLOSE_PARENTHESIS 
            {
              Object RESULT =null;
		int argExpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int argExpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object argExp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
        mipsGenerator.generatePrint(argExp.toString());
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("print",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // arguments ::= sec_arguments 
            {
              Object RESULT =null;
		int seqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int seqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object seq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = seq;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arguments",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // arguments ::= 
            {
              Object RESULT =null;
		 RESULT = ""; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arguments",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // evaluable ::= IDENTIFIER 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = id.toString();
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("evaluable",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // evaluable ::= literal 
            {
              Object RESULT =null;
		int litleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int litright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object lit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = lit;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("evaluable",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // evaluable ::= func_call 
            {
              Object RESULT =null;
		int callleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int callright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object call = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = call;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("evaluable",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // evaluable ::= array_access 
            {
              Object RESULT =null;
		int arrAccleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int arrAccright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object arrAcc = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = arrAcc;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("evaluable",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // sec_arguments ::= log_arith_expression SEPARATOR sec_arguments 
            {
              Object RESULT =null;
		int argleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int argright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object arg = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int seqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int seqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object seq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = arg + ":" + seq; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sec_arguments",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // sec_arguments ::= log_arith_expression 
            {
              Object RESULT =null;
		int argleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int argright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object arg = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = arg; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sec_arguments",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // param_declaration ::= type IDENTIFIER SEPARATOR param_declaration 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int parleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int parright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object par = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
            if (!symTable.addSymbolToScope(id.toString(), t + ":" + id)) {
                writeSemanticError("Error semantico: " + id + " es un parametro repetido. [Fila: " + idleft
                    + ", Col: " + idright);
            }
            RESULT = t + ":"  + par;
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("param_declaration",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // param_declaration ::= type IDENTIFIER 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int parIdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int parIdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object parId = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
            if(!symTable.addSymbolToScope(parId.toString(), t + ":" + parId)) {
                writeSemanticError("Error semantico: " + parId + " es un parametro repetido. [Fila: " + parIdleft
                    + ", Col: " + parIdright + "]");
            }
            RESULT = t.toString();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("param_declaration",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // func_parameters ::= param_declaration 
            {
              Object RESULT =null;
		int parDecleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int parDecright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object parDec = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = parDec;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("func_parameters",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // func_parameters ::= 
            {
              Object RESULT =null;
		 RESULT = ""; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("func_parameters",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // NT$0 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int funcIdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int funcIdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object funcId = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

        symTable.createScope(funcId.toString());
        symTable.currentFunction = funcId.toString();
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$0",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // NT$1 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int funcIdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int funcIdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object funcId = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object params = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
symTable.addToGlobalIfAbsent(funcId.toString(), t + ":" + funcId + ":" + params);
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$1",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // func ::= type func_name OPEN_PARENTHESIS NT$0 func_parameters CLOSE_PARENTHESIS NT$1 OPEN_BLOCK blocks CLOSE_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-9)).value;
		int funcIdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).left;
		int funcIdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).right;
		Object funcId = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-8)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object params = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		
            symTable.writeScope();
            symTable.popScope();
            symTable.currentFunction = "";
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("func",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // NT$2 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int funcNameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int funcNameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object funcName = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
symTable.createScope(funcName.toString());symTable.currentFunction = funcName.toString();
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$2",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // NT$3 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int funcNameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int funcNameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object funcName = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
symTable.addToGlobalIfAbsent(funcName.toString(), t + ":" + funcName + ":error");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$3",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // func ::= type func_name OPEN_PARENTHESIS NT$2 error CLOSE_PARENTHESIS NT$3 OPEN_BLOCK blocks CLOSE_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-9)).value;
		int funcNameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).left;
		int funcNameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).right;
		Object funcName = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-8)).value;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		
            System.out.println("Error en los parametros de la decl. de " + funcName + ":" + errleft + ", " + errright);
            symTable.writeScope();
            symTable.popScope();
            symTable.currentFunction = "";
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("func",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // functions ::= func 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("functions",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // functions ::= func functions 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("functions",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // functions ::= error 
            {
              Object RESULT =null;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("Error fatal en la decl de una func: " + errleft + ", " + errright);
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("functions",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // function_end ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_end",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // function_end ::= RETURN log_arith_expression 
            {
              Object RESULT =null;
		int retleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int retright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object ret = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
         if(!symTable.getType(exp.toString()).equals(symTable.getType(symTable.currentFunction))) {
            System.out.println("tipo de la exp: " + symTable.getType(exp.toString()));
            System.out.println("Func actual: " + symTable.currentFunction);
            System.out.println("tipo de la func: " + symTable.getType(symTable.currentFunction));
             writeSemanticError("Error semantico en el tipo de retorno de función [Fila, Col: " + expleft + ", " + expright + "]");
         }
     
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_end",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // function_end ::= RETURN 
            {
              Object RESULT =null;
		int retleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int retright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ret = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 writeSemanticError("Error semantico, el valor de retorno no coincide (no se permite retornar vacío). [Fila, "
        + retleft + ", Col: " + retright + "]"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_end",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // arith_operator ::= ADD 
            {
              Object RESULT =null;
		RESULT = "+";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arith_operator",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // arith_operator ::= SUBSTRACTION 
            {
              Object RESULT =null;
		RESULT = "-"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arith_operator",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // arith_operator ::= MULTIPLICATION 
            {
              Object RESULT =null;
		RESULT = "*";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arith_operator",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // arith_operator ::= DIVISION 
            {
              Object RESULT =null;
		RESULT = "/";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arith_operator",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // arith_operator ::= MODULO 
            {
              Object RESULT =null;
		RESULT = "%";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arith_operator",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // arith_operator ::= POWER 
            {
              Object RESULT =null;
		RESULT = "**";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arith_operator",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // unary_operator ::= INCREMENT 
            {
              Object RESULT =null;
		RESULT = "++";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unary_operator",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // unary_operator ::= DECREMENT 
            {
              Object RESULT =null;
		RESULT = "--";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unary_operator",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // logical_operator ::= CONJUNCTION 
            {
              Object RESULT =null;
		RESULT = "AND";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("logical_operator",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // logical_operator ::= DISJUNCTION 
            {
              Object RESULT =null;
		RESULT = "OR";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("logical_operator",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // relational_operator ::= LESSER_EQUAL 
            {
              Object RESULT =null;
		RESULT = "<=";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // relational_operator ::= GREATER_EQUAL 
            {
              Object RESULT =null;
		RESULT = ">=";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // relational_operator ::= LESSER 
            {
              Object RESULT =null;
		RESULT = "<";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // relational_operator ::= GREATER 
            {
              Object RESULT =null;
		RESULT = ">";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // relational_operator ::= EQUALS 
            {
              Object RESULT =null;
		RESULT = "==";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // relational_operator ::= DIFFERENT 
            {
              Object RESULT =null;
		RESULT = "!=";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // unary_operation ::= IDENTIFIER unary_operator 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int uOpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int uOpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object uOp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
        RESULT = id.toString();
        if (!symTable.isInsideLocalScope(id.toString())) {
            writeSemanticError("Error semantico en operacion unaria: el símbolo " + id.toString() +
                                " no se encuentra en este scope. " +
                                "[Fila: " + idleft + ", Columna: " + idright + "]");
        }

            mipsGenerator.generateUnaryOperation(id.toString(), uOp.toString());
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unary_operation",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // log_arith_expression ::= NEGATION log_arith_expression 
            {
              Object RESULT =null;
		int notleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int notright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object not = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int lalgexpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lalgexpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object lalgexp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = lalgexp.toString();
        mipsGenerator.generateLogicalNot(lalgexp.toString());
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("log_arith_expression",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // log_arith_expression ::= log_arith_expression logical_operator log_arith_expression 
            {
              Object RESULT =null;
		int expr1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int expr1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object expr1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int logOperleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int logOperright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object logOper = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object expr2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = expr1.toString();
        if (logOper.toString().equals("AND")) {
            mipsGenerator.generateLogicalAnd(expr1.toString(), expr2.toString());
        } else { // como no era un AND, la opcion restante es que sea un OR
            mipsGenerator.generateLogicalOr(expr1.toString(), expr2.toString());
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("log_arith_expression",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // log_arith_expression ::= comparison 
            {
              Object RESULT =null;
		int cmpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cmpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object cmp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = cmp;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("log_arith_expression",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // log_arith_expression ::= OPEN_PARENTHESIS log_arith_expression CLOSE_PARENTHESIS 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = exp.toString();
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("log_arith_expression",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // comparison ::= log_arith_expression relational_operator log_arith_expression 
            {
              Object RESULT =null;
		int expr1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int expr1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object expr1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int relOperleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int relOperright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object relOper = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object expr2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    if(!symTable.isValidOperation(expr1.toString(), relOper.toString(), expr2.toString())) {
            writeSemanticError(
            "Error semantico al comparar tipos que no son compatibles o están fuera del scope. (operacion: " +
                relOper.toString() + ") [Fila: " + relOperleft + ", Columna: " + relOperright + "]");
        }
        RESULT = "BOOL";
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("comparison",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // comparison ::= unary_operation 
            {
              Object RESULT =null;
		int uniOpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int uniOpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object uniOp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = uniOp;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("comparison",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // comparison ::= evaluable 
            {
              Object RESULT =null;
		int evleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int evright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ev = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
        RESULT = ev.toString();
        if (!symTable.isDataType(ev.toString()) && !symTable.isInsideLocalScope(ev.toString())) {
            writeSemanticError("Error semantico, identificador " + ev.toString() + " fuera del scope. [Fila, " + evleft
                + ", Columna: " + evright + "]");
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("comparison",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // comparison ::= log_arith_expression arith_operator log_arith_expression 
            {
              Object RESULT =null;
		int expr1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int expr1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object expr1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int arithOperleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int arithOperright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object arithOper = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object expr2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
            if(!symTable.isValidOperation(expr1.toString(), arithOper.toString(), expr2.toString())) {
                writeSemanticError(
                            "Error semantico al operar tipos que no son compatibles o están fuera del scope. (operacion: " +
                                arithOper.toString() + ") [Fila: " + arithOperleft + ", Columna: " + arithOperright + "]");
            }
            RESULT = expr1.toString();
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("comparison",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // update ::= ASSIGN 
            {
              Object RESULT =null;
		RESULT = "=";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("update",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // update ::= arith_operator ASSIGN 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = op.toString() + "=";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("update",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // assign_variable ::= IDENTIFIER update log_arith_expression 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int updleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int updright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object upd = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object expr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
        RESULT = id + ":" + upd + ":" + expr.toString();
            if(!symTable.checkType(id.toString(), expr.toString())) {
                writeSemanticError("Error semantico9: el tipo de " + id
                    + " no coincide con la expresión o hay un id fuera del scope [Fila: " + updleft + ", Columna: " + updright + "]");
            }
            // primero se calcula la expresion y luego se asigna
            String resultReg = mipsGenerator.generateArithmetic(expr.toString(), upd.toString(), "0");
            mipsGenerator.generateAssignment(id.toString(), resultReg);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assign_variable",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // array_access ::= IDENTIFIER OPEN_BRACKET log_arith_expression CLOSE_BRACKET 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object expr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    if(!symTable.isIntIndex(expr.toString())) {
        writeSemanticError("Error semantico: el tipo de dato de un índice debe ser entero. [Fila, " + exprleft + ", Columna: " + exprright + "]");
    }
    RESULT = id.toString();
    mipsGenerator.generateArrayAccess(id.toString(), expr.toString());
    RESULT = id.toString();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("array_access",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // array_assignment ::= IDENTIFIER ASSIGN OPEN_BLOCK arguments CLOSE_BLOCK 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int argsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object args = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    RESULT = id + ":" + args;
    if(!symTable.checkArray(symTable.getType(id.toString()), args.toString())) {
        writeSemanticError("Error semantico Array: no coincide el tipo de " + id + "con el de la expresión asignada: " + args
            + ". [Fila: " + argsleft + ", Columna: " + argsright + "]");
    }

    String[] values = args.toString().split(":");
    for (int i = 0; i < values.length; i++) {
    mipsGenerator.generateArrayAssignment(id.toString(), Integer.toString(i), values[i]);
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("array_assignment",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // index_assigment ::= array_access update log_arith_expression 
            {
              Object RESULT =null;
		int arrayleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int arrayright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object array = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object expr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = array.toString();
    if(!symTable.checkType(array.toString(), expr.toString())){
        writeSemanticError("Error semantico8: El tipo de una asignación no coincide o se usa un id fuera de scope. [Fila: " + opleft + ", Columna: " + opright + "]");
    }
    String resultReg = mipsGenerator.generateArithmetic(expr.toString(), op.toString(), "0");
    mipsGenerator.generateArrayAssignment(array.toString(), "index", resultReg);

    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("index_assigment",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // assignments ::= index_assigment 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assignments",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // assignments ::= assign_variable 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assignments",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // assignments ::= array_assignment 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assignments",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // array_declaration ::= ASSIGN OPEN_BLOCK sec_arguments CLOSE_BLOCK 
            {
              Object RESULT =null;
		int seqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int seqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object seq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = seq.toString();
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("array_declaration",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // array_declaration ::= 
            {
              Object RESULT =null;
		 RESULT = ""; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("array_declaration",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // decl_and_assign ::= type IDENTIFIER ASSIGN log_arith_expression 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = t.toString();
    if(!symTable.addSymbolToScope(id.toString(), t.toString() + ":" + id)) {
        writeSemanticError("Error semantico10: la variable declarada " + id + " ya existe. [Fila: " + idleft
            + ", Col: " + idright + "]");
    }if(!symTable.checkType(t.toString(), exp.toString())) {
        writeSemanticError("Error semantico11: la declaracion no coincide en tipos o se usa un id fuera de scope. [Fila: "
            + idleft + ", Col:" + idright + "]");
    }
    String resultReg = mipsGenerator.generateArithmetic(exp.toString(), "=", "0"); // Initialize variable
    mipsGenerator.generateAssignment(id.toString(), resultReg); // Assign value


    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("decl_and_assign",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // compound_decl ::= type IDENTIFIER 
            {
              Object RESULT =null;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object tipo = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = tipo.toString();
        if(!symTable.addSymbolToScope(id.toString(), tipo.toString() + ":" + id)) {
            writeSemanticError("Error semantico: el identificador " + id + " ya existe en este scope. [Fila: " + idleft
                + ", Col: " + idright + "]");
        }
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("compound_decl",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // compound_decl ::= decl_and_assign 
            {
              Object RESULT =null;
		int decleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int decright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object dec = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = dec;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("compound_decl",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // compound_decl ::= type array_access array_declaration 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int arrAccleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int arrAccright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object arrAcc = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int arrDecleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int arrDecright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object arrDec = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = t.toString();
    if(!symTable.addSymbolToScope(arrAcc.toString(), t.toString() + ":" + arrAcc.toString())) {
        writeSemanticError("Error semantico95: la declaracion de " + arrAcc + " no es posible pues ya hay "
            + " una en este scope. [Fila: " + arrAccleft + ", Col: " + arrAccright + "]");
    }if(!symTable.checkArray(t.toString(), arrDec.toString())) {
        writeSemanticError("Error en la declaracion de arreglo: el tipo de algun elemento no coincide o no esta en el scope."
            + " Fila: " + arrDecleft + ", Col: " +arrDecright);
    }
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("compound_decl",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // NT$4 ::= 
            {
              Object RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object cond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
symTable.createScope("cond if"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$4",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // NT$5 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object cond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
 symTable.writeScope(); symTable.popScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$5",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // if_expr ::= IF OPEN_PARENTHESIS log_arith_expression CLOSE_PARENTHESIS OPEN_BLOCK NT$4 blocks CLOSE_BLOCK NT$5 optional_else 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		Object cond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int elseResultleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int elseResultright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object elseResult = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
        String elseLabel = mipsGenerator.generateIf(cond.toString());
        if (elseResult != null && !elseResult.toString().isEmpty()) {
            mipsGenerator.generateElse(elseLabel);
        }
        mipsGenerator.generateEndIf(elseLabel);
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("if_expr",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // NT$6 ::= 
            {
              Object RESULT =null;
RESULT = "error"; System.out.println("Error sintáctico en la definición de un for."); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$6",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // NT$7 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 symTable.createScope("cond if"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$7",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // if_expr ::= IF error NT$6 OPEN_BLOCK NT$7 blocks CLOSE_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		symTable.writeScope(); symTable.popScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("if_expr",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // NT$8 ::= 
            {
              Object RESULT =null;
symTable.createScope("cond else"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$8",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // else_expr ::= ELSE OPEN_BLOCK NT$8 blocks CLOSE_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 symTable.writeScope(); symTable.popScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("else_expr",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // optional_else ::= else_expr 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_else",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // optional_else ::= 
            {
              Object RESULT =null;
		 RESULT = "";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_else",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // cases ::= CASE literal COLON blocks cases 
            {
              Object RESULT =null;
		int litleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int litright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object lit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		
        //RESULT = lit + ":" + cs;
        String typeLit = symTable.getType(lit.toString());
        if(!typeLit.equals("CHAR") && !typeLit.equals("INT")) {
            writeSemanticError("Error semantico en case: el valor debe ser un literal tipo int o char [Fila: " + litleft
                + ", Col: " + litright + "]");
        }if (!symTable.switchDataType.equals(typeLit)) {
            writeSemanticError("Error semantico en case: el tipo no coincide con el de la expresion en el switch ("
                + symTable.switchDataType + "). [Fila: " + litleft + ", Col: " + litright + "]");
        }
        /*if(symTable.isDuplicateCase(lit.toString())) {
            writeSemanticError("Error semantico en case: no pueden existir valores duplicados: " + lit.toString()
                + ". [Fila: " + litleft + ", Col: " + litright + "]");
        }*/
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cases",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // cases ::= CASE literal COLON blocks 
            {
              Object RESULT =null;
		int litleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int litright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object lit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
        RESULT = lit.toString();
/*        if(symTable.isDuplicateCase(lit.toString())) {
            writeSemanticError("Error semantico en case: no pueden existir valores duplicados: " + lit.toString()
                + ". [Fila: " + litleft + ", Col: " + litright + "]");
        }*/
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cases",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // NT$9 ::= 
            {
              Object RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object expr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;

        symTable.switchDataType = symTable.getType(expr.toString());
        /*symTable.clearCaseValues();*/
        // si esta en el scope, entonces revisa que ademas sea de los 2 tipos que se puede hacer (int y char)
        if(!symTable.getType(expr.toString()).equals("INT") && !symTable.getType(expr.toString()).equals("CHAR")) {
            writeSemanticError("Error semantico en switch: el tipo de " + expr + " debe ser CHAR o INT y es: "
            + symTable.getType(expr.toString()) + ". [Fila: " + exprleft + ", Col: " + exprright + "]");
        }
        symTable.createScope("switch expr");
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$9",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // switch_expressions ::= SWITCH OPEN_PARENTHESIS log_arith_expression CLOSE_PARENTHESIS OPEN_BLOCK NT$9 cases optional_default CLOSE_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Object expr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int csleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int csright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object cs = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 symTable.writeScope(); symTable.popScope(); symTable.switchDataType = "";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("switch_expressions",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // NT$10 ::= 
            {
              Object RESULT =null;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
RESULT = "ERROR"; System.err.println("Error sintáctico en la definición de un switch. [" + errleft + ", " + errright + "]"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$10",54, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // NT$11 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
 symTable.createScope("switch expr"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$11",55, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // switch_expressions ::= SWITCH error NT$10 OPEN_BLOCK NT$11 cases optional_default CLOSE_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int csleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int csright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object cs = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 symTable.writeScope(); symTable.popScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("switch_expressions",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // optional_default ::= DEFAULT COLON blocks 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_default",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // optional_default ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_default",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // block ::= if_expr 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("block",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // block ::= while_expressions 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("block",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // block ::= for_expressions 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("block",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // block ::= simple_expressions END_EXPRESSION 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("block",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // block ::= switch_expressions 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("block",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // blocks ::= block blocks 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("blocks",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // blocks ::= error 
            {
              Object RESULT =null;
		 System.out.println("ERROR dentro de bloque") ;  RESULT = "ERROR"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("blocks",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // blocks ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("blocks",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // initialization ::= assign_variable 
            {
              Object RESULT =null;
		int varAssignleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int varAssignright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object varAssign = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
        RESULT = varAssign;
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("initialization",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // initialization ::= IDENTIFIER 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = id;
         if(!symTable.isInsideLocalScope(id.toString())) {
                writeSemanticError("Error semantico: identificador " + id + " fuera del scope. [Fila, " + idleft + ", Columna: " + idright + "]");}
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("initialization",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // initialization ::= decl_and_assign 
            {
              Object RESULT =null;
		int decAssignleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int decAssignright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object decAssign = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = decAssign;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("initialization",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // simple_operation ::= unary_operation 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_operation",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // simple_operation ::= decl_and_assign 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_operation",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // simple_expressions ::= unary_operation 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expressions",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // simple_expressions ::= compound_decl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expressions",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // simple_expressions ::= assignments 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expressions",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // simple_expressions ::= read 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expressions",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // simple_expressions ::= print 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expressions",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // simple_expressions ::= BREAK 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expressions",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // simple_expressions ::= func_call 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expressions",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // simple_expressions ::= function_end 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expressions",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // simple_expressions ::= error 
            {
              Object RESULT =null;
		 RESULT = "Error"; System.err.println("Error sintáctico en la definición de una expresión simple."); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expressions",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // NT$12 ::= 
            {
              Object RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object cond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
symTable.createScope("ciclo while"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$12",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // while_expressions ::= WHILE OPEN_PARENTHESIS log_arith_expression CLOSE_PARENTHESIS OPEN_BLOCK NT$12 blocks CLOSE_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Object cond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		 symTable.writeScope(); symTable.popScope(); 
        String labels = mipsGenerator.generateWhileStart();
        mipsGenerator.generateWhileCondition(cond.toString(), labels);
        mipsGenerator.generateWhileEnd(labels);
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("while_expressions",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // NT$13 ::= 
            {
              Object RESULT =null;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
RESULT = "error";
        System.err.println("Error sintáctico en la definición de un while. [fila, col: " + errleft + ", " + errright + "]");
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$13",57, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // NT$14 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
 symTable.createScope("ciclo while"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$14",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // while_expressions ::= WHILE error NT$13 OPEN_BLOCK NT$14 blocks CLOSE_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$14
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		 symTable.writeScope(); symTable.popScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("while_expressions",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // NT$15 ::= 
            {
              Object RESULT =null;
symTable.createScope("ciclo for"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$15",59, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // for_expressions ::= FOR OPEN_PARENTHESIS NT$15 initialization SEPARATOR log_arith_expression SEPARATOR simple_operation CLOSE_PARENTHESIS OPEN_BLOCK blocks CLOSE_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$15
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-9)).value;
		 symTable.writeScope(); symTable.popScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("for_expressions",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-11)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // NT$16 ::= 
            {
              Object RESULT =null;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
RESULT = "error";
        System.err.println("Error sintáctico en la definición de un for. [fila, col: " + errleft + ", " + errright + "]");
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$16",60, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // NT$17 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
 symTable.createScope("ciclo for"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$17",61, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // for_expressions ::= FOR error NT$16 OPEN_BLOCK NT$17 blocks CLOSE_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$17
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int errleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		 symTable.writeScope(); symTable.popScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("for_expressions",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // program ::= functions 
            {
              Object RESULT =null;
		 System.out.println("Se parseó un archivo fuente."); symTable.writeGlobalScope();
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // program ::= 
            {
              Object RESULT =null;
		 System.out.println("Archivo fuente vacío."); RESULT = ""; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
